import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:mynotes/services/cloud/cloud_note.dart';
import 'package:mynotes/services/cloud/cloud_storage_constants.dart';
import 'package:mynotes/services/cloud/cloud_storage_exceptions.dart';
/*Each document = one note
Each document has its own unique documentId generated by Firestore 
document id is basically note id
in our database we are creating note with feild of user id and text field 
which is stored in one doctument */

class FirebaseCloudStorage {
  final notes = FirebaseFirestore.instance.collection('notes');
  //it is giving notes collection from firestore

  Future<void> deleteNote({required String documentId}) async {
    try {
      await notes.doc(documentId).delete();
    } catch (e) {
      throw CouldNotDeleteNoteException();
    }
  }

  Future<void> updateNote({
    required String documentId,
    required String text,
  }) async {
    try {
      await notes.doc(documentId).update({textFieldName: text});
    } catch (e) {
      throw CouldNotUpdateNoteException();
    }
  }

/*allNotes() = live stream of notes for a user, automatically updates UI when
 data changes, acts like a cache of current user notes. */

  Stream<Iterable<CloudNote>> allNotes({required String ownerUserId}) =>

      /*notes.snapshots() → returns Stream<QuerySnapshot>
Each event emitted by the stream is a QuerySnapshot, i.e., a snapshot of all
 documents at that moment. */

      /*since snapshots is giving stream of list of notes we are using 2 map
 1 for stream other for list of doc */

//docs is List<QueryDocumentSnapshot<Map<String, dynamic>>>

      notes.snapshots().map((event) => event.docs
          .map((doc) => CloudNote.fromSnapshot(doc))
          .where((note) => note.ownerUserId == ownerUserId));

  Future<Iterable<CloudNote>> getNotes({required String ownerUserId}) async {
    try {
      return await notes
          /*where is a firestore method it is used to filter the data inside document
      it returns querysnapshot */
          .where(
            ownerUserIdFieldName,
            isEqualTo: ownerUserId,
          )

          /*querysnapshot is a container for all the documents returned by a Firestore query.
          .docs → A list of QueryDocumentSnapshot, i.e., all documents returned by the query. */

          /*get is a Firestore method to fetch the documents once from the database.
            Returns a QuerySnapshot containing all the documents that match the query.
            it this case it is fetching data for where()  */
          .get()

          /*Dart Future method that runs a function after the asynchronous fetch is complete.
            value = the QuerySnapshot returned by .get().
            Analogy: Once Firestore returns the data, do this with it. */

          //docs is list of documents returned by a query.
          //doc A single document inside .docs.

          /*We use docs instead of doc because a query can return multiple
           documents, so Firestore gives us a list of documents (docs) to 
           handle all matches; doc is just one item in that list. */

          .then(
            /* 
          here, value is the result (QuerySnapshot) returned by get().
          value.docs = list of all documents returned by the query.
          For each doc in docs with the help of map(), we convert it into
          a CloudNote object. Finally, we return an Iterable of CloudNote objects.
          */

            (value) => value.docs.map((doc) => CloudNote.fromSnapshot(doc)),
          );
    } catch (e) {
      throw CouldNotGetAllNotesException();
    }
  }

  Future<CloudNote> createNewNote({required String ownerUserId}) async {
    /*notes.add({...}) → adds a new document in Firestore
// returns DocumentReference (just a pointer to the document, no data) 
 thats why we are using get()*/

    final document = await notes.add({
      ownerUserIdFieldName: ownerUserId,
      textFieldName: '',
    });

/*we have reference or address in document where data is stored but not actual
data for fetching data we are using get it returns a DocumentSnapshot  */

    final fetchedNote = await document.get();

//this is converting the added note in our define note remember here there is only 1 note

    return CloudNote(
      documentId: fetchedNote.id,
      ownerUserId: ownerUserId,
      text: '',
    );
  }

  static final FirebaseCloudStorage _shared =
      FirebaseCloudStorage._sharedInstance();

  FirebaseCloudStorage._sharedInstance();
  factory FirebaseCloudStorage() => _shared;
}

/*/*  
Why we use static + private constructor + factory for Singleton in Dart:

1) Singleton means only ONE object of a class should exist in the whole app.  
   Example: Firebase, Database, Logger → we don't want multiple objects.

2) In Dart, calling MyClass() normally creates a NEW object each time.
   We need a way to:
      - Create object ONCE
      - Reuse the SAME object every time.

3) Dart has no "singleton" keyword, so we use three things together:
   a) Static variable → exists only once in memory, stores the single object.
   b) Private constructor → stops others from creating objects directly.
   c) Factory constructor → returns the same existing object instead of creating new.

4) How it works:
   - Static variable creates object ONCE when the class is loaded.
   - Private constructor ensures only the class controls object creation.
   - Factory constructor always gives back the same single object.

5) Other ways (like global variables) exist, but this one is CLEAN, SAFE, and RECOMMENDED.
*/
 */


//production mode and test mode in firebase cloude if not rember revise it