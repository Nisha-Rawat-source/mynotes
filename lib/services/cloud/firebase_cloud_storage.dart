import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:mynotes/services/cloud/cloud_note.dart';
import 'package:mynotes/services/cloud/cloud_storage_constants.dart';
import 'package:mynotes/services/cloud/cloud_storage_exceptions.dart';
/*Each document = one note
Each document has its own unique documentId generated by Firestore 
document id is basically note id
in our database we are creating note with feild of user id and text field 
which is stored in one doctument */

class FirebaseCloudStorage {
  final notes = FirebaseFirestore.instance.collection('notes');
  //it is giving notes collection from firestore

  Future<void> deleteNote({required String documentId}) async {
    try {
      await notes.doc(documentId).delete();
    } catch (e) {
      throw CouldNotDeleteNoteException();
    }
  }

  Future<void> updateNote({
    required String documentId,
    required String text,
  }) async {
    try {
      await notes.doc(documentId).update({textFieldName: text});
    } catch (e) {
      throw CouldNotUpdateNoteException();
    }
  }

/*allNotes() = live stream of notes for a user, automatically updates UI when
 data changes, acts like a cache of current user notes. */

  Stream<Iterable<CloudNote>> allNotes({required String ownerUserId}) {
    /*notes.snapshots() → returns Stream<QuerySnapshot>
Each event emitted by the stream is a QuerySnapshot, i.e., a snapshot of all
 documents at that moment. */

    /*since snapshots is giving stream of list of notes we are using 2 map
 1 for stream other for list of doc */

//docs is List<QueryDocumentSnapshot<Map<String, dynamic>>>

    final allNotes = notes
        .where(ownerUserIdFieldName, isEqualTo: ownerUserId)
        .snapshots()
        .map((event) => event.docs.map((doc) => CloudNote.fromSnapshot(doc)));

    return allNotes;
  }

  Future<CloudNote> createNewNote({required String ownerUserId}) async {
    /*notes.add({...}) → adds a new document in Firestore
// returns DocumentReference (just a pointer to the document, no data) 
 thats why we are using get()*/

    final document = await notes.add({
      ownerUserIdFieldName: ownerUserId,
      textFieldName: '',
    });

/*we have reference or address in document where data is stored but not actual
data for fetching data we are using get it returns a DocumentSnapshot  */

    final fetchedNote = await document.get();

//this is converting the added note in our define note remember here there is only 1 note

    return CloudNote(
      documentId: fetchedNote.id,
      ownerUserId: ownerUserId,
      text: '',
    );
  }

  static final FirebaseCloudStorage _shared =
      FirebaseCloudStorage._sharedInstance();

  FirebaseCloudStorage._sharedInstance();
  factory FirebaseCloudStorage() => _shared;
}

/*/*  
Why we use static + private constructor + factory for Singleton in Dart:

1) Singleton means only ONE object of a class should exist in the whole app.  
   Example: Firebase, Database, Logger → we don't want multiple objects.

2) In Dart, calling MyClass() normally creates a NEW object each time.
   We need a way to:
      - Create object ONCE
      - Reuse the SAME object every time.

3) Dart has no "singleton" keyword, so we use three things together:
   a) Static variable → exists only once in memory, stores the single object.
   b) Private constructor → stops others from creating objects directly.
   c) Factory constructor → returns the same existing object instead of creating new.

4) How it works:
   - Static variable creates object ONCE when the class is loaded.
   - Private constructor ensures only the class controls object creation.
   - Factory constructor always gives back the same single object.

5) Other ways (like global variables) exist, but this one is CLEAN, SAFE, and RECOMMENDED.
*/
 */


//production mode and test mode in firebase cloude if not rember revise it